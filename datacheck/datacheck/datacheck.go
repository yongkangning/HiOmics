package datacheck

import (
	"bytes"
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"os"
	"path"
	"regexp"
	"strings"

	"github.com/saintfish/chardet"
	"github.com/shakinm/xlsReader/xls"
	"github.com/xuri/excelize/v2"
	"golang.org/x/text/encoding/simplifiedchinese"
	"golang.org/x/text/encoding/unicode"
	"golang.org/x/text/transform"
)

func DataCheck(inputFile string, checkHeader string, checkHeaderDuplicate string, outputFile string, resultSeparator string, checkRowDuplicate string) {
	log.Printf("[INFO] Starting Data Verification for the file %s.\n", path.Base(inputFile))
	var resSep rune
	if resultSeparator == "0" {
		resSep = '\t'
	} else {
		resSep = ','
	}
	var stringBuffer *bytes.Buffer
	// Determine the file type: txt, xls, xlsx.
	if strings.HasSuffix(inputFile, ".xls") {
		_, err := xls.OpenFile(inputFile)
		if err == nil {
			log.Println("[INFO]", path.Base(inputFile), " is a xls type of Excel.")
			stringBuffer, err = getxlsData(inputFile)
			if err != nil {
				log.Fatalln("[ERRO]", path.Base(inputFile), ": Read failed, please check the file format.", err)
			}
		} else {
			log.Println("[WRAN]", path.Base(inputFile), ": The file extension is xls, but it cannot be opened in Excel format. Try processing in text format.")
			var err error
			stringBuffer, err = getTextData(inputFile)
			if err != nil {
				log.Fatalln("[ERRO]", path.Base(inputFile), ": Read failed, please check the file format.", err)
			}
		}
	} else if strings.HasSuffix(inputFile, ".xlsx") {
		file, err := excelize.OpenFile(inputFile)
		if err == nil {
			log.Println("[INFO]", path.Base(inputFile), "is a xlsx type of Excel.")
			file.Close()
			stringBuffer, err = getxlsxData(inputFile)
			if err != nil {
				log.Fatalln("[ERRO]", path.Base(inputFile), ": Read failed, please check the file format.", err)
			}
		} else {
			log.Println("[WARN]", path.Base(inputFile), ": The file extension is xlsx, but it cannot be opened in Excel format. Try processing in text format.")
			var err error
			stringBuffer, err = getTextData(inputFile)
			if err != nil {
				log.Fatalln("[ERRO]", path.Base(inputFile), ": Read failed, please check the file format.", err)
			}
		}
	} else if strings.HasSuffix(inputFile, ".gz") || strings.HasSuffix(inputFile, ".zip") || strings.HasSuffix(inputFile, ".rar") {
		log.Fatalf("%s is in compressed format, only text or Excel type files are supported.\n", path.Base(inputFile))
	} else {
		// 文本类型
		log.Println("[INFO]", path.Base(inputFile), ": The file format is text type.")
		var err error
		stringBuffer, err = getTextData(inputFile)
		if err != nil {
			log.Fatalln("[ERRO]", path.Base(inputFile), ": Read failed, please check the file format.", err)
		}
	}
	//fmt.Println(stringBuffer.String())
	// If the last line does not have a newline character, add a newline character at the end.
	if !strings.HasSuffix(stringBuffer.String(), "\n") {
		stringBuffer.WriteString("\n")
	}
	// Delimiter detection
	sep := detectSeparator(inputFile, *stringBuffer)
	// Output result file
	outFile, err := os.OpenFile(outputFile, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0664)
	if err != nil {
		log.Fatalln("[ERRO]", outFile, "create failed：", err)
	}
	defer outFile.Close()
	writer := csv.NewWriter(outFile)
	writer.Comma = resSep
	var cols []string
	rowNames := make([]string, 0, 10)
	nrow := 0
	firstRowLen := 0
	re, err := regexp.Compile("^[a-zA-Z].*")
	if err != nil {
		log.Println(err)
	}
	for {
		line, err := stringBuffer.ReadString('\n')
		if err == io.EOF {
			break
		}
		// 剔除window生成的换行符号
		// Eliminate newline characters generated by Windows
		line = strings.TrimSuffix(line, "^M")
		//line = strings.TrimSpace(line)
		//line = strings.Trim(line, "\n")
		// 剔除换行键(10)以及utf16转uft8在开头生成的3个特殊字符
		// Remove newline character (10) and the first three special characters generated by utf16 to utf8 conversion
		line = strings.Trim(line, string([]byte{239, 187, 191, 10}))
		// 跳过空白行
		// Skip blank lines
		if len(line) == 0 {
			continue
		}
		// 如果是分隔符为空格，按空白字符分割
		// If the delimiter is a space, split by white space characters.
		nrow++
		if sep == " " {
			cols = strings.Fields(line)
		} else {
			cols = strings.Split(line, sep)
		}
		// 删除每个字段前后空白字符和双引号
		// Remove white space characters and double quotes before and after each field.
		for index := range cols {
			cols[index] = strings.Trim(strings.TrimSpace(cols[index]), "\"")
		}
		rowNames = append(rowNames, cols[0])
		// 检查列名
		if checkHeader == "true" {
			if nrow == 1 {
				// 删除转换后开头几个特殊字符byte{239, 187, 191}
				// Remove the first few special characters byte{239, 187, 191} after conversion.
				// 表头必须大小写字符开头
				// The table header must start with a capital or lowercase letter.
				for n, col := range cols {
					if col == "" {
						// 允许第一列(n==0)为空，这在表达矩阵中很常见
						// allowing the first column(n==0) to be empty, which is common in expressing matrices.
						if n >= 1 {
							log.Fatalf("[ERRO] The column name cannot be empty, the %d column is empty, please check the data.\n", n+1)
						}
					} else if !re.MatchString(col) {
						log.Fatalf("[ERRO] The name of the %d column: %s does not meet the standard. Column names can only start with upper or lower case letters, not with numbers or special characters, please check the data.\n", n+1, col)
					}
				}
				// 检查表头是否重复
				if checkHeaderDuplicate == "true" {
					repeatCol := checkRepeat(cols)
					if len(repeatCol) > 0 {
						log.Fatalf("[ERRO] The column names in the first row cannot be duplicated, the following column names are duplicated: %s, please check the data.", strings.ReplaceAll(fmt.Sprintf("%v", repeatCol), "map", ""))
					}
				}
				firstRowLen = len(cols)
			}
			if nrow == 2 {
				if firstRowLen != len(cols) {
					log.Fatalf("[ERRO] The number of columns in the first row and the second row are not consistent, the number of columns in the first row: %d, the number of columns in the second row: %d, please check if there are any column names in the first column that are empty.", firstRowLen, len(cols))
				}
			}
		}
		writer.Write(cols)

	}
	// 检查行名
	// 检查第一列（行名）是否有重复
	if checkRowDuplicate == "true" {
		log.Println("[INFO] Check if row names are duplicated:")
		repeatRowName := checkRepeat(rowNames)
		if len(repeatRowName) > 0 {
			log.Fatalf("[ERRO] The first column is the row name, which cannot be duplicated. The following row names are duplicated: %s, please check the data.", strings.ReplaceAll(fmt.Sprintf("%v", repeatRowName), "map", ""))
		} else {
			log.Println("[INFO] Check completed, no duplicate row names.")
		}
	}
	writer.Flush()
	log.Printf("[INFO] Data validation completed for file %s.\n", path.Base(inputFile))
}

func getxlsxData(fileName string) (*bytes.Buffer, error) {
	file, err := excelize.OpenFile(fileName)
	stringBuffer := bytes.NewBufferString("")
	tempString := make([]string, 0, 100)
	if err != nil {
		return stringBuffer, err
	}
	defer func() {
		if err := file.Close(); err != nil {
			fmt.Println(err)
		}
	}()
	rows, err := file.GetRows(file.GetSheetList()[0])
	if err != nil {
		return stringBuffer, err
	}
	for _, row := range rows {
		for _, colCell := range row {
			tempString = append(tempString, colCell)
		}
		stringBuffer.WriteString(strings.Join(tempString, "\t") + "\n")
		tempString = tempString[:0]
	}
	return stringBuffer, err
}

func getxlsData(fileName string) (*bytes.Buffer, error) {
	workbook, err := xls.OpenFile(fileName)
	stringBuffer := bytes.NewBufferString("")
	tempString := make([]string, 0, 100)
	if err != nil {
		return stringBuffer, err
	}
	sheet, err := workbook.GetSheet(0)
	if err != nil {
		return stringBuffer, err
	}
	for i := 0; i <= sheet.GetNumberRows(); i++ {
		row, err := sheet.GetRow(i)
		if err != nil {
			return stringBuffer, err
		}
		for _, col := range row.GetCols() {
			tempString = append(tempString, col.GetString())

		}
		stringBuffer.WriteString(strings.Join(tempString, "\t") + "\n")
		tempString = tempString[:0]
	}
	return stringBuffer, nil
}

func getTextData(fileName string) (*bytes.Buffer, error) {
	file, err := os.Open(fileName)
	defer file.Close()
	stringBuffer := bytes.NewBufferString("")
	if err != nil {
		return stringBuffer, err
	}
	data, err := io.ReadAll(file)
	if err != nil {
		return stringBuffer, err
	}
	// 编码检测
	// Encoding detection
	detector := chardet.NewTextDetector()
	ResCharset, err := detector.DetectBest(data)
	if err != nil {
		return stringBuffer, err
	}
	chset := ResCharset.Charset
	log.Println("[INFO]", path.Base(fileName), "Character encoding is presumed to be: ", chset)
	var transData []byte
	//var err error
	// UTF-16BE UTF-16LE GB-18030  excel > windows-1252
	// 同一个文件会随机出现编码判断为Big5 EUC-JP EUC-KR这几种格式的情况，待处理
	switch {
	case ResCharset.Charset == "UTF-16LE":
		transData, err = Utf16le2Utf8(data)
		if err != nil {
			return stringBuffer, err
		}
	case ResCharset.Charset == "UTF-16BE":
		transData, err = Utf16be2Utf8(data)
		if err != nil {
			return stringBuffer, err
		}
	case ResCharset.Charset == "GB-18030":
		transData, err = Gbk2Utf8(data)
		if err != nil {
			return stringBuffer, err
		}
	//case ResCharset.Charset == "UTF-8":
	//	transData = data
	//case ResCharset.Charset == "ASCII":
	//	transData = data
	//case strings.HasPrefix(ResCharset.Charset, "ISO-"):
	//	transData = data
	default:
		transData = data
		//err = errors.New("Unsupported file encoding format: " + chset)
	}
	//stringBuffer.WriteString(string(transData))
	stringBuffer.Write(transData)
	return stringBuffer, err
}

func Gbk2Utf8(s []byte) ([]byte, error) {
	reader := transform.NewReader(bytes.NewReader(s), simplifiedchinese.GBK.NewDecoder())
	data, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	str := string(data)
	return []byte(str), nil
}

func Utf16le2Utf8(s []byte) ([]byte, error) {
	decoder := unicode.UTF16(unicode.LittleEndian, unicode.IgnoreBOM).NewDecoder()
	data, err := decoder.Bytes(s[:])
	// data, _, err := transform.Bytes(unicode.UTF16(unicode.LittleEndian, unicode.IgnoreBOM).NewDecoder(), s)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func Utf16be2Utf8(s []byte) ([]byte, error) {
	decoder := unicode.UTF16(unicode.BigEndian, unicode.IgnoreBOM).NewDecoder()
	data, err := decoder.Bytes(s[:])
	//data, _, err := transform.Bytes(unicode.UTF16(unicode.BigEndian, unicode.IgnoreBOM).NewDecoder(), s)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func detectSeparator(filename string, s bytes.Buffer) (sep string) {
	tabCount := strings.Count(s.String(), "\t")
	commaCount := strings.Count(s.String(), ",")
	spaceCount := strings.Count(s.String(), " ")
	log.Println("[INFO] tabCount:", tabCount, "commaCount:", commaCount, "spaceCount:", spaceCount)
	if tabCount >= 1 && tabCount > commaCount && tabCount > spaceCount {
		sep = "\t"
		log.Println("[INFO]", path.Base(filename), "The delimiter is a tab.")
	} else if commaCount >= 1 && commaCount > tabCount && commaCount > spaceCount {
		sep = ","
		log.Println("[INFO]", path.Base(filename), "The delimiter is a comma.")
	} else if spaceCount >= 1 && spaceCount > tabCount && spaceCount > commaCount {
		sep = " "
		log.Println("[INFO]", path.Base(filename), "The delimiter is a space.")
	} else {
		sep = "\t"
		log.Println("[INFO]", path.Base(filename), "The default delimiter is a tab. If this does not match reality, please change the file delimiter to a tab or a comma delimiter.")
	}
	return sep
}

func checkRepeat(data []string) map[string]int {
	count := make(map[string]int)
	for _, v := range data {
		count[v] += 1
	}
	repeatData := make(map[string]int)
	for _, v := range data {
		if count[v] > 1 {
			repeatData[v] = count[v]
		}
	}
	return repeatData
}
